package minimum_time

import "slices"

// 鸽巢原理
// 构造问题
// 贡献法
// 排序
// 动态规划: 01背包问题 首先基于nums2的值将nums1重新排序，剩下的就是01背包问题，
//    因为对于每一个数字我们只有选或者不选，选了的话一定是分配最大的时机

// 1、鸽巢原理：首先一个关键点在于想到答案至多为N，因为这是很显而易见的事实，第二次操作总比第一次操作更优，
// 因此对于每一个nums1中的数字最多操作一次。（反悔贪心的思想） 

// 2、构造问题：因此问题转换为考虑如何分配操作的时机使得能够得到的和最小。枚举操作的次数k，
// 问题转换为从nums1中选取K个数字，并且进行恰当的时机分配，计算得到的最小和。 

// 3、贡献法：考虑最小和等价于没有操作下的和减去最大贡献，而这个贡献是一个变化的函数（相当于泛化的物品），
// 不同的时机对应不同的贡献值，其中贡献值为nums1[i]+jnums2[i]，j是其中的操作时间。
// 对于最大贡献问题，发现直接暴力计算难度骤增（泛化的背包dp），考虑优化。 

// 4、排序：首先可以发现无论怎么变化，nums1[i]不会被j影响，所以总的贡献值一定包含了所有的nums1[i]，
// 变化的玩意在于jnums2[i]，首先我们已经明确知道了总共有0,1,2,..j-1可以选，还是贪心的思想，
// 我们将小的系数给小的nums2[i]匹配掉，把大的留给大的nums2[i]，可以使用交换法证明这样产生的贡献值最大。 

// 5、动态规划求解：基于4的分析，首先基于nums2的值将nums1重新排序，剩下的就是01背包问题，
// 因为对于每一个数字我们只有选或者不选，选了的话一定是分配最大的时机
func minimumTime(nums1, nums2 []int, x int) int {
	s1, s2, n := 0, 0, len(nums1)
	id := make([]int, n)
	for i := range id {
		id[i] = i
		s1 += nums1[i]
		s2 += nums2[i]
	}
	// 对下标数组排序，避免破坏 nums1 和 nums2 的对应关系
	slices.SortFunc(id, func(i, j int) int { return nums2[i] - nums2[j] })

	f := make([]int, n+1)
	for i, p := range id {
		a, b := nums1[p], nums2[p]
		for j := i + 1; j > 0; j-- {
			f[j] = max(f[j], f[j-1]+a+b*j)
		}
	}

	for t, v := range f {
		if s1+s2*t-v <= x {
			return t
		}
	}
	return -1
}
